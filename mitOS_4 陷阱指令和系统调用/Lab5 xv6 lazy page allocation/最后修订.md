==具有较高鲁棒性的实现，自认为大大优于答案的实现==

只完善了 usertrap  的逻辑，其他实现不变

---

我们知道页面错误的触发的原因有几种吗？

1.  页表项（pte）缺失或者无效
```
if(pte == 0 || (*pte & PTE_V) == 0)
```
2.  尝试写入只读页面
```
if (r_scause() == 15 && (*pte & PTE_W) == 0) 
```
3.  尝试读取不可读页面
```
if (r_scause() == 13 && (*pte & PTE_R) == 0)
```
4.  用户态访问内核页面
```
if ((*pte & PTE_U) == 0) 
```
5.  其他未知原因


懒分配的只针对于我们设计的有效的地址
`PGROUNDUP(p->trapframe->sp) - 1 < fault_va && fault_va < p->sz && fault_va < MAXVA`

所以在这个有效的地址上触发的页面错误会导致懒分配，但是！！！！！==**不是这个有效的地址上触发的所有页面错误都会导致懒分配**！！！！！==

==导致懒分配的只有第一种页面错误：页表项（pte）缺失或者无效==

至此我们可以以更严谨的逻辑进行页面错误和懒分配的处理：

页面触发的判断条件为r_scause() == 13 || r_scause() == 15
↓
对于进入这个条件的所有情况逐一处理
↓
- 页表项（pte）缺失或者无效：
     若是在有效地址范围内触发的页面错误无论哪种按照懒分配处理；
     若不是在有效地址范围内触发的页面错误则杀死进程
     
（**如果出错的虚拟地址合法且页表项存在且有效，那就是访问页面权限出错的问题了**，分别检查处理写入只读页面，读取不可读页面，用户态访问内核页面，和其他的未知原因）

- 尝试写入只读页面
      打印错误日志，杀死进程
- 尝试读取不可读页面
	  打印错误日志，杀死进程
- 用户态访问内核页面
      打印错误日志，杀死进程
-  其他未知原因
      打印错误日志，杀死进程



trap.c : usertrap
```
//
// handle an interrupt, exception, or system call from user space.
// called from trampoline.S
//
void
usertrap(void)
{
 ...
  } else if(r_scause() == 13 || r_scause() == 15) {
        uint64 fault_va = r_stval();
        char* pa;

        if(fault_va >= MAXVA || fault_va < 0){
            printf("usertrap: invalid address %p\n", fault_va);
            p->killed = 1;
        } else {
            pte_t *pte = walk(p->pagetable, PGROUNDDOWN(fault_va), 0);
            if (pte == 0 || (*pte & PTE_V) == 0) {
                if(PGROUNDUP(p->trapframe->sp) - 1 < fault_va && fault_va < p->sz && fault_va < MAXVA && (pa = kalloc()) != 0) {
                memset(pa, 0, PGSIZE);
                    if(mappages(p->pagetable, PGROUNDDOWN(fault_va), PGSIZE, (uint64)pa, PTE_R | PTE_W | PTE_X | PTE_U) != 0) {
                        kfree(pa);
                        p->killed = 1;
                    }
                } else{
                    p->killed = 1;  // 页面表项不存在或无效，非法访问
                }
            }else{
                // 已映射，检查权限
                if (r_scause() == 15 && (*pte & PTE_W) == 0) {
                    // 尝试写入只读页面
                    printf("usertrap: attempt to write read-only page at %p\n", fault_va);
                    p->killed = 1;
                } else if (r_scause() == 13 && (*pte & PTE_R) == 0) {
                    // 尝试读取不可读页面
                    printf("usertrap: attempt to read non-readable page at %p\n", fault_va);
                    p->killed = 1;
                } else if ((*pte & PTE_U) == 0) {
                    // 用户态访问内核页面
                    printf("usertrap: user access to kernel page at %p\n", fault_va);
                    p->killed = 1;
                } else {
                    // 其他未知原因
                    printf("usertrap: unknown page fault at %p\n", fault_va);
                    p->killed = 1;
                }
            }
        }
  } else {
    printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
    printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
    p->killed = 1;
  }

  if(p->killed)
    exit(-1);

  // give up the CPU if this is a timer interrupt.
  if(which_dev == 2)
    yield();

  usertrapret();
}
```

