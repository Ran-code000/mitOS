### 总结重点

1. **配置差异**：内核空间陷阱用 kernelvec（stvec 指向），利用已有内核页表和栈，简化处理。
2. **保存与恢复**：kernelvec 将寄存器保存在内核栈，sret 恢复，确保线程状态完整。
3. **陷阱处理**：kerneltrap 处理设备中断（devintr）或异常（panic），计时器中断可能触发 yield。
4. **线程切换**：栈保存支持线程切换，yield 后返回依赖保存状态。
5. **过渡安全**：用户到内核时调整 stvec，中断禁用确保设置安全。

这个机制就像一个高效的紧急响应系统，利用内核的“内部优势”（已有上下文）快速处理陷阱，同时通过栈管理支持线程切换，确保系统稳定运行。

---
### 详细解释

#### 1. 内核空间陷阱的配置

- **stvec 设置**：当 CPU 执行内核代码时，stvec 指向 kernelvec（kernelvec.S:10），一个汇编实现的陷阱入口。
- **上下文优势**：内核已经设置了 satp（指向内核页表）和有效的栈指针（内核栈），无需像用户空间那样切换页表。

#### 2. 进入陷阱：kernelvec

- **保存寄存器**：kernelvec 将所有 32 个寄存器压入当前线程的内核栈，确保被中断的代码状态完整保存。
- **栈选择**：使用线程的内核栈保存状态。如果陷阱导致线程切换（如 yield），新线程会使用自己的栈，被中断线程的状态留在其栈上，互不干扰。
- **跳转**：保存完成后，跳转到 kerneltrap（trap.c:134）处理具体逻辑。

#### 3. 处理陷阱：kerneltrap

- **两种情况**：
    - **设备中断**：调用 devintr（trap.c:177）检查并处理（如磁盘完成信号）。
    - **异常**：内核中异常是致命的，调用 panic 停止系统。
- **计时器中断**：如果触发原因是计时器中断且当前是进程的内核线程（非调度线程），调用 yield 让出 CPU，切换到其他线程（详见第 7 章）。
- **状态保护**：kerneltrap 开始时保存 sepc（程序计数器）和 sstatus（状态），因为 yield 可能覆盖它们。

#### 4. 返回内核代码

- **恢复状态**：kerneltrap 完成后，恢复保存的 sepc 和 sstatus。
- **执行 sret**：kernelvec 从栈中弹出寄存器，执行 sret，将 sepc 复制到 pc，恢复被中断的内核代码。

#### 5. 计时器中断的特殊性

- **问题思考**：计时器中断触发 yield 后，线程可能暂停，控制权交给其他线程。后来，当被中断线程恢复时，陷阱返回到其保存的 sepc，从栈中恢复寄存器，继续执行。
- **机制保障**：栈保存和线程切换确保状态不丢失。

#### 6. 用户到内核的过渡

- **切换 stvec**：从用户空间进入内核时（如 usertrap），stvec 被设为 kernelvec，以处理内核中的陷阱。
- **中断禁用**：RISC-V 在陷阱开始时自动禁用中断（SIE 清零），xv6 在设置 stvec 前不启用中断，避免窗口期问题。