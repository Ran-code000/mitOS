
### 类比理解

- **用户态**：
    - 像普通员工，只能用办公室设备，不能进机房。
- **核心态**：
    - 像管理员，可以控制电源、服务器。
- **系统调用**：
    - 像员工提交申请单，管理员审核后操作设备。
- **强隔离**：
    - 像锁住机房门，员工只能通过申请单（ecall）访问。
---

1. **用户态与核心态的定义**：
    - **用户态（User Mode）**：应用程序运行的受限模式，只能执行普通指令。
    - **核心态（Supervisor Mode）**：内核运行的特权模式，可执行特权指令（如管理硬件）。
2. **强隔离的必要性**：
    - 应用程序可能出错或恶意操作，强隔离确保：
        - 操作系统和其他应用程序不受影响。
        - 操作系统能清理失败程序并继续运行。
    - 要求：应用程序不能访问或修改内核数据结构、指令，或其他进程内存。
3. **CPU 的硬件支持**：
    - RISC-V 提供三种模式：
        - **机器模式**：最高特权，启动时配置硬件，Xv6 仅短暂使用。
        - **管理模式**：内核运行，允许特权指令。
        - **用户模式**：程序运行，权限受限。
    - 用户态尝试特权操作，CPU 切换到管理模式，内核处理异常。
4. **系统调用机制（系统调用：用户态到核心态的桥梁）**：
    - 用户态程序通过 ecall 等指令调用内核功能（如 read），从用户模式切换到管理模式。
    - 内核验证参数，执行或拒绝操作，返回结果。
    - 内核控制入口点，确保安全性（防止恶意绕过验证）。
	
	#### 系统调用过程（以 read 为例）

 **用户态代码**
```
char buf[10];
read(0, buf, 10); // 读取标准输入
```
read 是库函数，内部调用 ecall。

- **发出系统调用**：
    - ecall 指令执行：
        - CPU 从用户模式切换到管理模式。
        - 跳转到内核预定义的入口点（如 Xv6 的 syscall 函数）。
        - ecall 触发 RISC-V 的异常，硬件将控制权交给内核的陷阱处理程序（kernel/trap.c 的 **usertrap**），它最终**调用** kernel/syscall.c 的 syscall() 函数
- **内核处理**：
    - 内核验证参数：
        - 检查文件描述符 0 是否有效。
        - 确保 buf 是用户合法内存地址。
        - 验证 10 是否合理。
    - 执行操作：
        - 从标准输入读取 10 字节到 buf。
    - 返回结果：
        - 通过寄存器（如 a0）返回读取的字节数。
        - 用 sret 指令返回用户模式。
- **返回用户态**：
    - 程序继续执行，buf 中有输入数据。


5. **空间划分**：
    - **用户空间**：用户态程序运行的环境。
    - **内核空间**：管理模式下内核运行的环境。

**核心观点**：强隔离通过 CPU 模式和系统调用建立应用程序与操作系统之间的硬边界，确保安全性和稳定性。

---

**用户态尝试特权操作**：

- 程序运行：
```
int main() {
    asm("csrw sstatus, 0"); // 尝试写状态寄存器（特权指令）
}
```

**结果**：

- CPU 检测到用户态执行特权指令，触发异常。
- 切换到管理模式，内核终止程序（输出类似“illegal instruction”）。

#### 恶意程序

- **恶意代码**：

```
int main() {
    char *kernel_mem = (char *)0x80000000; // 假设内核地址
    *kernel_mem = 'x'; // 尝试写内核内存
}
```

**结果**：

- CPU 检测到非法内存访问，trap 到管理模式。
- 内核终止程序（“segmentation fault”）。