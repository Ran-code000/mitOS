
### 类比理解

- **进程**：
    - 像独立公寓，住户（线程）有私有空间（地址空间）。
- **页表**：
    - 像门牌号，虚拟地址是房间号，映射到真实地址。
- **线程与栈**：
    - 像住户带两套衣服，用户态穿便服（用户栈），进管理室换工装（内核栈）。
- **系统调用**：
    - 像敲物业门（ecall），请求服务。

---

1. **进程的隔离作用**：
	- 通过页表隔离内存，线程切换 CPU，防止干扰
    - 进程是隔离单位，防止一个进程干扰另一个进程（内存、CPU、文件描述符）或内核。
    - 内核需谨慎实现，防范有缺陷或恶意的程序绕过隔离。

#### 例子：

- **场景**：运行两个程序 prog1（打印 "Hello"）和 prog2（恶意读内存）。
- **无隔离**：
    - prog2 可能直接访问 prog1 的内存，篡改数据。
- **有隔离（Xv6 进程）**：
    - prog1 和 prog2 是独立进程，各自有私有地址空间，prog2 无法读取 prog1 的内存。


1. **实现机制**：
    - **用户/管理模式**：区分权限，限制用户态操作。
    - **地址空间**：通过页表为每个进程提供私有内存。
    - **时间切片**：线程切换实现 CPU 共享。
2. **私有机器假象**：
    - 进程提供独立的地址空间（私有内存）和线程（模拟私有 CPU）。
3. **页表与地址空间**：
    - Xv6 用 RISC-V 页表映射虚拟地址到物理地址。
    - 每个进程有单独页表，用户空间布局：指令、全局变量、栈、堆。
    - 地址上限为 0x3fffffffff（MAXVA），顶部保留 trampoline 和 trapframe。

- 从虚拟地址 0 开始：
    1. 指令（代码）。
    2. 全局变量。
    3. 栈区。
    4. 堆区（malloc 使用）。
- 顶部：trampoline 和 trapframe（用于用户/内核切换）

1. **进程状态管理**：
    - 内核用 proc 结构体维护状态：
        - p->pagetable：页表。
        - p->kstack：内核栈。
        - p->state：状态（分配、就绪、运行、阻塞、退出）。
    - **状态变化**：
		- 初始：p->state = ALLOCATED（进程创建）。
		- 运行：p->state = RUNNING（执行用户代码）。
		- 阻塞：p->state = SLEEPING（等待 read 输入）。
		- 恢复：p->state = RUNNABLE（输入完成，可运行）。
2. **线程与栈**：
    - 每个进程有一个线程，执行指令，可挂起/恢复。
    - 双栈设计：
        - 用户栈：用户态使用。
        - 内核栈：内核态使用，独立且受保护。
    - 线程在用户栈和内核栈间切换。
3. **系统调用流程**：

    - **用户态**：
	    - read 调用触发 ecall。
	    - 用户栈保存参数（0, buf, 10）。
	- **进入内核**：
	    - CPU 切换到管理模式，跳到 trampoline。
	    - 切换到 p->kstack，调用 sys_read
    - **返回用户态**：
		- sret 降低特权级，恢复用户栈。
		- buf 包含输入数据，程序继续。
```
int main() {
    char buf[10];
    read(0, buf, 10); // 系统调用
    printf("%s\n", buf);
    return 0;
}
```

```
int sys_read() {
    int fd, n;
    char *buf;
    argint(0, &fd);
    argptr(1, &buf, &n);
    argint(2, &n);
    return fileread(fget(fd), buf, n);
}
```
**核心观点**：Xv6 通过进程抽象，利用页表、线程切换和系统调用，提供强隔离和私有资源假象，确保安全性和独立性。

---

### 总结

- **进程隔离**：
    - 通过页表隔离内存，线程切换 CPU，防止干扰。
- **地址空间**：
    - 每个进程有独立虚拟内存，由 p->pagetable 定义。
- **线程运行**：
    - 双栈设计，用户态和内核态交替执行。
- **系统调用**：
    - ecall 和 sret 实现用户/内核切换。
- **状态管理**：
    - proc 结构体记录进程状态，确保隔离和调度。