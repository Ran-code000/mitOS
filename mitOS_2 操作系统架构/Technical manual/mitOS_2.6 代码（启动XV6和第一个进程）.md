

- **启动流程**：
    - 硬件加载内核 -> 机器模式设置栈 -> 切换管理模式 -> 初始化并运行第一个进程 -> 执行 /init 和 shell。
- **关键点**：
    - _entry 和 start 完成硬件到内核过渡。
    - userinit 和 initcode 创建用户进程。
    - /init 启动系统服务。 通过例子可以看出，Xv6 从裸机到用户交互逐步构建

### 类比理解

- **上电到 _entry**：
    - 像打开电源，工人（引导程序）搬机器（内核）到车间。
- **start 到 main**：
    - 像工人设置工具（栈、时钟），交给管理员（管理模式）。
- **userinit 到 /init**：
    - 像管理员雇佣第一个员工（进程），让他运行办公室（shell）


1. **硬件启动**：
    - RISC-V 上电后，引导加载程序（bootloader）从只读内存运行，将 Xv6 内核加载到物理地址 0x80000000（避开 I/O 设备区域 0x0 到 0x7fffffff）。
2. **机器模式初始化**：
    - CPU 从 _entry（kernel/entry.S:6）开始执行，处于机器模式，分页禁用（虚拟地址 = 物理地址）。
    - _entry 设置栈（stack0 + 4096），调用 start（kernel/start.c:21）。  
3. **切换到管理模式**：
    - start 在机器模式下配置：
        - 设置 mstatus 为管理模式。
        - 将 mepc 设为 main 函数地址。
        - 禁用分页（satp = 0）。
        - 初始化时钟中断。
    - 用 mret 跳转到 main，进入管理模式。
4. **内核初始化**：
    - main（kernel/main.c:11）初始化设备和子系统，调用 userinit 创建第一个进程。
5. **第一个进程**：
    - userinit（kernel/proc.c:212）创建进程，运行 initcode.S（user/initcode.S:1）。  
    - initcode 用 exec 系统调用加载 /init。
6. **用户环境启动**：
    - /init（user/init.c:15）创建控制台设备，打开文件描述符 0、1、2，启动 shell，完成系统启动。

**核心观点**：Xv6 从硬件上电经过引导加载、机器模式配置(entry->start)、管理模式切换(start->main)、内核初始化(main->userinit)，最终创建第一个用户进程(userinit->initcode.S，initcode->exec->/init)，运行第一个用户进程(/init->shell)，逐步建立操作系统环境。

---
补充现代操作系统启动全过程（以 Linux 为例）

#### 1. 硬件上电与 BIOS/UEFI 初始化

- **描述**：
    - 计算机通电，CPU 开始执行固化在主板上的固件代码（传统 BIOS 或现代 UEFI）。
- **细节**：
    - **BIOS**：  
        - CPU 从地址 0xFFFF0 执行跳转指令（JMP），进入 BIOS 代码（存储在 ROM 或闪存中）。
    - **UEFI**：  
        - 现代系统使用 UEFI，启动更灵活，支持 GPT 分区和图形界面。
    - **POST（加电自检）**：
        - 检查硬件（如 CPU、内存、键盘），确保正常运行。
    - **启动顺序**：
        - BIOS/UEFI 根据配置（如 CMOS 设置）读取启动顺序（boot sequence），确定从哪个设备启动（如硬盘、U盘）。
- **类比**：
    - **餐厅经理（BIOS/UEFI）检查餐厅设施**：
        - 餐厅停业一夜后，经理早上到达，打开电源（通电），检查厨房设备（CPU）、桌椅（内存）、水电（硬件）是否正常运行。这是开业前的例行检查（POST）。经理查看开业计划表（启动顺序），决定从哪个食材仓库（启动设备，如硬盘）开始准备。
    - 屏幕显示：
```
BIOS Version 1.0
Memory Test: 16 GB OK
Booting from SATA0...
```

#### 2. 加载 MBR 或 UEFI 引导程序

- **描述**：
    - BIOS/UEFI 将控制权交给启动设备的引导代码。
- **BIOS + MBR**：
    - **步骤**：
        1. BIOS 将启动设备（如硬盘）的第一个扇区（MBR，512 字节）加载到内存 0x7C00。
        2. 检查 MBR 签名（最后 2 字节为 0x55AA），验证有效性。
        3. 执行 MBR 代码。
    - **MBR 结构**：
        - 引导代码（446 字节）。
        - 分区表（64 字节，4 个主分区）。
        - 签名（2 字节）。
    - MBR 伪代码：
```
    MBR:
    scan_partition_table
    load_active_partition_sector(0x7C00)
    jmp 0x7C00
```

- **UEFI**：  
    - UEFI 直接加载分区上的 EFI 文件（如 /EFI/BOOT/BOOTX64.EFI），无需 MBR。
    
- **类比**：
    - **经理（BIOS/UEFI）交给仓库管理员（MBR/EFI）钥匙**：
        - 经理确认设施正常后，走到仓库门口，把钥匙交给仓库管理员（MBR），让他去取食材清单（分区表）。如果是新式餐厅（UEFI），经理直接用电子钥匙打开仓库（EFI 文件），无需传统管理员。
- **例子**：
    - 传统餐厅：经理（BIOS）说：“管理员（MBR），去仓库取食材清单（分区表）。”
    - 新式餐厅：经理（UEFI）刷卡（UEFI）直接进入。



#### 3. 加载 PBR 或 EFI 引导管理器

- **BIOS + MBR**：
    - **描述**：
        - MBR 扫描分区表，找到活动分区，加载其第一个扇区（PBR，Partition Boot Record）到 0x7C00。
    - **步骤**：
        1. MBR 读取分区表，找到标记为“active”的分区。
        2. 加载 PBR，跳转执行。

```
PBR:
    load_sector(bootmgr, 0x10000)
    jmp 0x10000
```

- **UEFI**： 
    - UEFI 执行 EFI 应用程序（如 GRUB 的 EFI 版本），直接读取文件系统。
- **类比**：
    - **仓库管理员（MBR）找到具体货架管理员（PBR）**：
        - 仓库管理员（MBR）查看清单（分区表），找到标有“今日特供”（活动分区）的货架，唤醒货架管理员（PBR）来取食材。新式餐厅中，经理（UEFI）直接叫来高级订货员（GRUB）。
- **例子**：
    - 管理员（MBR）喊：“ *货架管理员（PBR），你负责特供货架，快去取食材！”
    
#### 4. 加载启动管理器

- **描述**：
    - PBR 或 UEFI 加载启动管理器（如 GRUB、Windows Boot Manager）。
- **细节**：
    - **GRUB**（常用 Linux 启动管理器）：
        - 读取配置文件（如 /boot/grub/grub.cfg），提供启动菜单。
    - **位置**：
        - GRUB 通常安装在 MBR 后的扇区（GRUB Stage 1.5）或分区中。
- **过程**：
    1. 显示启动选项。
    2. 用户选择操作系统。
- **例子**：
    - GRUB 菜单（grub.cfg）：


```
Ubuntu 20.04 LTS (5.15.0-73-generic)
Windows 10
```


- 配置文件（简化）：

```
menuentry 'Ubuntu' {
    linux /boot/vmlinuz-5.15.0 root=/dev/sda1
    initrd /boot/initrd.img-5.15.0
}
```

- **类比**：
    - **货架管理员（PBR）请来订货员（GRUB）**：
        - 货架管理员（PBR）把食材清单交给订货员（GRUB），订货员展示今日菜单（grub.cfg），让餐厅经理（用户）选择想做的菜品（操作系统）。
- **例子**：
    - 订货员说：“经理，今天有‘Ubuntu 套餐’和‘Windows 大餐’，选哪个？”

#### 5. 加载内核

- **描述**：
    - 启动管理器加载 Linux 内核镜像（vmlinuz）和初始 RAM 磁盘（initrd 或 initramfs）到内存。
- **细节**：
    - vmlinuz：压缩的内核文件。
    - initrd：临时文件系统，包含驱动和启动脚本。
    - 加载地址：通常为 0x100000（内核）和 0x2000000（initrd）。
- **过程**：
    1. GRUB 读取文件路径，加载到内存。
    2. 设置 CPU 寄存器（如 eip），跳转到内核入口。
- **例子**：
    - GRUB 输出：
    （版本信息是内核启动的第一条输出）

```
Loading Linux 5.15.0-73-generic ...
Loading initial ramdisk ...
```

- **类比**：
    - **订货员（GRUB）把主厨（内核）和工具箱（initrd）带到厨房**（内存）：
        - 订货员根据经理的选择，把行李箱（vmlinuz）和他的临时工具箱（initrd）带到厨房（内存），交给主厨开始工作。
- **例子**：
    - 订货员（GRUB）说：“主厨（内核），Ubuntu 套餐食材在仓库 1（/boot），工具箱（initrd）也拿来了。”

#### 6. 内核解压与初始化

- **描述**：
    - 内核入口代码解压自身，初始化 CPU 和基本硬件。
- **步骤**：
    1. **解压**：
        - vmlinuz 自解压到内存。
    2. **模式切换**：
        - 从实模式切换到保护模式（32 位或 64 位）。
    3. **硬件初始化**：
        - 设置临时页表、中断描述符表（IDT）。
- **代码示例**（简化）：

```
start:
    call decompress_kernel
    mov $0x1000000, %esp  # 设置栈
    jmp start_kernel      # 进入 C 代码
```


- 输出：
```
Decompressing Linux... done
```

- **类比**：
    - **主厨（内核）打开行李箱，准备厨房**：
        - 主厨到达后，打开压缩行李箱（解压 vmlinuz），拿出厨具（保护模式），整理灶台（CPU）、冰箱（内存），准备烹饪。
- **例子**：
    - 主厨说：“行李箱打开了（解压 vmlinuz），灶台就位，开始干活！”

#### 7. 内核主函数（start_kernel）

- **描述**：
    - 进入 start_kernel（init/main.c），执行全面初始化。
- **步骤**：
    1. **架构初始化**：
        - 检测 CPU 类型，设置页表。
    2. **内存管理**：
        - 初始化 MMU 和内存分配器。
    3. **中断与调度**：
        - 设置中断控制器（APIC）和任务调度器。
    4. **参数解析**：
        - 处理 GRUB 传递的命令行（如 root=/dev/sda1）。
- **代码示例**（简化）

```
void start_kernel(void) {
    setup_arch();
    mm_init();
    sched_init();
    init_IRQ();
    parse_args("root=/dev/sda1");
    rest_init();
}
```

- 输出：

```
Linux version 5.15.0-73-generic
Initializing cgroup subsys cpuset
```

- **类比**：
    - **主厨（内核）布置厨房生产线**：
        - 主厨安排冰箱分区（内存管理）、点火（中断）、设置烹饪计划（调度器），检查菜单要求（内核参数）。
- **例子**：
    - 主厨喊：“冰箱分好区了（内存管理），火开了(中断），今天做 Ubuntu 套餐！”

#### 8. 加载 initramfs 并挂载临时根文件系统

- **描述**：
    - 内核加载并解压 initramfs，挂载为临时根文件系统。
- **细节**：
    - initramfs 是 cpio 格式的内存文件系统，包含模块和 /init 脚本。
    - （cpio 是一种归档格式（类似 tar），用于将文件和目录打包成单个文件。如命令中用的是 initramfs-busybox-x86.cpio.gz，说明这是一个用 gzip 压缩的 cpio 归档。）
- **过程**：
    1. 解压到内存。
    2. 挂载为 /。
    3. 执行 /init。
	    如（BusyBox 是你 initramfs 的核心组件，提供了一个精简的用户空间环境。它在内核启动后接管控制权，执行 /init 脚本，并提供基本的 shell（/bin/sh）和工具，完成系统的初始化）
- **例子**：
    - /init 脚本（简化）：
```
#!/bin/sh
mount -t proc proc /proc
modprobe ext4
exec switch_root /mnt /sbin/init
```

输出：

```
Unpacking initramfs...
```

- **类比**：
    - **主厨（内核）打开临时工具箱（initramfs）**：
        - 主厨打开订货员给的工具箱（initrd），拿出临时食材和刀具（驱动和脚本），在临时灶台（/）上开始准备。
- **例子**：
    - 主厨说：“工具箱里有刀和调料，先用这些做准备。”

#### 9. 加载设备驱动与模块

- **描述**：
    - 加载必要的硬件驱动（如磁盘、USB）。
- **细节**：
    - 内核内置部分驱动，initramfs 提供额外模块。
- **例子**：
    - 加载磁盘驱动：

```
modprobe nvme
```

输出：

```
[  1.234567] nvme nvme0: pci device registered
```

- **类比**：
    - **主厨（内核）从工具箱取专用厨具（驱动）**：
        - 主厨从工具箱拿出烤盘（磁盘驱动）、搅拌器（网络驱动），安装到灶台。
- **例子**：
    - 主厨说：“烤盘（磁盘驱动）装好了，可以烤面包了。”

#### 10. 挂载真实根文件系统

- **描述**：
    - 挂载真实的根文件系统（如 /dev/sda1），替换 initramfs。
- **过程**：
    1. 根据参数定位根分区。
    2. 挂载到临时目录。
    3. 用 switch_root 切换。
- **例子**：
    - 输出：
```
Mounting /dev/sda1 on /mnt
Switching root...
```

- **类比**：
    - **主厨（内核）搬进正式厨房（根文件系统）**：
        - 主厨确认食材齐全，把临时灶台（/）收拾掉，搬到正式厨房（/dev/sda1），开始大规模烹饪。
- **例子**：
    - 主厨说：“临时灶台（/）不用了，搬到大厨房（/dev/sda1）开干！”
#### 11. 启动用户空间（/sbin/init）

- **描述**：
    - 内核执行 /sbin/init（通常是 systemd），启动用户空间。
- **步骤**：
    1. 初始化系统服务（如网络、日志）。
    2. 启动登录界面或 shell。
- **例子**：
    - systemd 输出：
```
[  OK  ] Started Network Manager.
[  OK  ] Reached target graphical.target.
```

- **类比**：
    - **主厨（内核）叫来服务员（systemd）开业**：
        - 主厨把厨房交给服务员（systemd），服务员布置餐桌（服务）、打开大门（终端/图形界面）。
- **例子**：
    - 服务员说：“桌子摆好了，门开了，欢迎顾客！”

#### 12. 系统完全运行

- **描述**：
    - 系统启动完成，用户可交互。
- **例子**：
    - 用户登录，运行：

```
lsblk
```
- 或启动桌面环境。

- **类比**：
    - **餐厅正式营业，顾客（用户）点餐**：
        - 餐厅开门营业，顾客进来点餐（运行程序），享受服务。
- **例子**：
    - 顾客说：“来份 Ubuntu 套餐！”（运行 lsblk）。

---
### 完整流程总结

1. **硬件上电**：BIOS/UEFI 自检，读取启动顺序。
2. **加载 MBR/EFI**：BIOS 加载 MBR 或 UEFI 执行 EFI 文件。
3. **加载 PBR/EFI 管理器**：MBR 加载 PBR 或 UEFI 加载 GRUB。
4. **加载启动管理器**：GRUB 显示菜单。
5. **加载内核**：加载 vmlinuz 和 initrd。
6. **内核解压与初始化**：解压，进入保护模式。
7. **内核主函数**：初始化硬件和调度。
8. **加载 initramfs**：挂载临时根文件系统。
9. **加载驱动**：加载硬件模块。
10. **挂载真实根文件系统**：切换到 /dev/sda1。
11. **启动用户空间**：运行 /sbin/init（systemd）。
12. **系统运行**：用户交互环境就绪。

---

### 类比理解

### 完整类比流程总结

1. **餐厅经理（BIOS/UEFI）检查设施**：通电，检查设备，选仓库。
2. **经理交给仓库管理员（MBR/EFI）钥匙**：加载 MBR 或 EFI。
3. **仓库管理员找货架管理员（PBR）**：加载活动分区 PBR。
4. **货架管理员请订货员（GRUB）**：加载启动管理器，选菜品。
5. **订货员带主厨（内核）和工具箱（initrd）**：加载内核到内存。
6. **主厨打开行李箱（解压vmlinuz）**：解压，准备厨房。
7. **主厨布置生产线（start_kernel）**：初始化硬件和调度。
8. **主厨用临时工具箱（initramfs）**：挂载临时根文件系统。
9. **主厨取专用厨具（驱动）**：加载设备模块。
10. **主厨搬进正式厨房（根文件系统）**：切换到真实根。
11. **主厨叫服务员（systemd）开业**：启动用户空间。
12. **餐厅营业，顾客点餐（用户交互）**：系统运行。

---

    - 经理（BIOS/UEFI）负责开业检查。
    - 仓库管理员（MBR）到订货员（GRUB）逐步传递任务。
    - 主厨（内核）从准备到烹饪。
    - 服务员（systemd）接手服务。
    - 食材（操作系统）、工具箱（initrd）、厨房（内存）贯穿始终。

---
根据实验环境搭建可以更好的了解启动过程
[](https://gitee.com/kpyang5/sysu-2025-spring-operating-system#课前准备)

### 类比理解

- **打包 cpio**：
    - 你把 BusyBox（多功能工具箱）装进一个包裹（cpio），交给主厨（内核）。
- **启动过程**：
    1. **经理（BIOS）检查餐厅**：QEMU 模拟硬件，BIOS 初始化。
    2. **订货员（QEMU）带主厨（内核）和工具箱（initramfs）**：加载 bzImage 和 cpio.gz。
    3. **主厨打开行李箱和工具箱**：内核解压并运行 initramfs。
    4. **主厨用工具箱（BusyBox）准备**：执行 /init，启动 shell。
    5. **服务员（BusyBox shell）招呼顾客**：进入 / # ，用户交互。
- **BusyBox 的作用**：
    - 像一个万能服务员，既能做饭（/init），又能招呼顾客（shell）