## 重点总结

1. **死锁成因**：
    - 多个锁获取顺序不一致，导致循环等待。
    - 示例：路径1（A→B）与路径2（B→A）冲突。
2. **锁排序解决**：
    - ***全局一致的锁获取顺序***（如cons.lock→p->lock），打破循环。
    - 成为***函数规范***的一部分。
3. **xv6实例**：
    - ***consoleintr：cons.lock先于进程锁***。
    - 文件系统：目录锁→inode锁→缓冲区锁等。
4. **设计挑战**：
    - 逻辑冲突：模块调用与锁顺序不符。
    - 动态锁：锁身份需运行时确定。
    - 细粒度：锁增多加剧死锁风险。
5. **原则**：
    - 固定顺序、层次设计，平衡正确性与性能。
---


### 1. 什么是死锁？

**定义**：死锁（deadlock）是指多个线程（或进程）因互相等待对方持有的资源（通常是锁）而无法继续执行的状态。所有线程都被阻塞，形成一个循环等待的闭环。

***死锁的四个必要条件***（Coffman条件）：

1. **互斥**：资源（如锁）一次只能被一个线程持有。
2. **持有并等待**：线程持有至少一个资源，同时等待另一个资源。
3. **不可抢占**：资源只能由持有者自愿释放。
4. **循环等待**：线程形成一个循环，每个等待前一个持有的资源。

---

### 2. 死锁的成因：锁顺序不一致

如果多个代码路径需要同时持有多个锁，且获取锁的顺序不一致，就可能导致死锁。

#### 文中例子

- **场景**：
    - 代码路径1：先获取锁A，再获取锁B。
    - 代码路径2：先获取锁B，再获取锁A。
- **执行过程**：
    1. 线程T1（路径1）：获取锁A，尝试获取锁B。
    2. 线程T2（路径2）：获取锁B，尝试获取锁A。
    3. T1等待T2释放B，T2等待T1释放A。
- **结果**：T1和T2互相等待，形成死锁。

#### 类比：餐厅点餐

- **场景**：
    - 顾客A需要叉子和刀子，先拿叉子。
    - 顾客B需要刀子和叉子，先拿刀子。
- **死锁**：
    - A拿了叉子，等待刀子。
    - B拿了刀子，等待叉子。
    - 两人都不放手，无法吃饭。
- **解决**：规定顺序（如都先拿叉子再拿刀子），避免循环等待。

---

### 3. 锁排序的作用

**解决方法**：通过***全局锁获取顺序（lock ordering）*** 避免死锁。所有代码路径必须以相同的顺序获取多个锁，打破循环等待条件。

#### 原则

- **一致性**：无论代码路径如何，锁的获取顺序固定。
- **规范性**：锁顺序成为函数接口的一部分，调用者必须遵守。

#### 文中解决

- 所有代码路径约定：先获取锁A，再获取锁B。
- **执行**：
    - T1：拿A，再拿B。
    - T2：拿A（若T1持有则等待），再拿B。
- **结果**：顺序一致，T2等待T1释放A，无死锁。

---

### 4. xv6中的锁排序实例

xv6通过全局锁顺序避免死锁，以下是具体例子：

#### 4.1 consoleintr中的锁链

- **场景**：中断处理程序consoleintr处理输入字符（如换行符），唤醒等待输入的进程。
- **锁**：
    - ***cons.lock：保护控制台缓冲区***。
    - ***p->lock：等待进程的锁（在wakeup中获取）***。
- **顺序**：cons.lock → p->lock。
- **代码**（kernel/console.c:138）：
    
```
acquire(&cons.lock);
// 处理输入
wakeup(proc); // 获取proc->lock
release(&cons.lock);
```
    
- **原因**：
    - wakeup需要修改进程状态，获取p->lock。
    - 若反过来（先p->lock后cons.lock），可能与另一路径冲突。
- **全局规则**：cons.lock必须在任何进程锁之前获取。

#### 4.2 文件系统中的长锁链

- **场景**：创建文件涉及多个资源。
- **锁**：
    1. 目录的锁（dir->lock）。
    2. 新文件inode的锁（inode->lock）。
    3. 磁盘块缓冲区的锁（buf->lock）。
    4. 磁盘驱动器的锁（vdisk_lock）。
    5. 调用进程的锁（p->lock）。
- **顺序**：按上述顺序获取。
- **原因**：
    - 文件操作需要按层次访问资源（如先找目录，再分配inode）。
    - 一致顺序避免循环等待。
- **例子**：
    - 创建文件时，先锁目录，找到空闲inode后锁inode，最后更新进程状态。

---

### 5. 锁排序的挑战

锁排序看似简单，但实现中可能面临以下困难：

#### 5.1 与逻辑结构冲突

- **问题**：模块调用顺序与锁顺序相反。
- **例子**：
    - 模块M1调用M2，逻辑上M1先执行。
    - 但锁顺序要求M2的锁在M1的锁之前。
- **解决**：
    - 在M1调用M2前提前获取M2的锁。
    - 或调整代码逻辑，符合锁顺序。

#### 5.2 锁身份未知

- **问题**：需要持有锁才能确定下一个锁。
- **例子**：
    - 文件系统路径解析（如/a/b/c）：
        - 锁住/a，解析后发现/b，再锁/b。
    - ***wait/exit：扫描进程表，锁住父进程后查找子进程***。
- **解决**：
    - 动态调整，但保持层次顺序（如父目录锁→子目录锁）。

#### 5.3 细粒度锁的复杂性

- **问题**：锁越多，死锁可能性越大。
- **例子**：
    - 粗粒度锁：一个大锁保护文件系统，简单但性能差。
    - 细粒度锁：每个资源一个锁，增加并发但需小心排序。
- **解决**：
    - 谨慎设计锁粒度，平衡性能与复杂性。

---

### 6. 类比与举例

#### 类比：图书馆借书

- **场景**：
    - 学生A借书1和书2，先锁书1。
    - 学生B借书2和书1，先锁书2。
- **死锁**：
    - A拿书1，等书2。
    - B拿书2，等书1。
- **锁排序**：
    - 规定按书号顺序借（书1→书2）。
    - A和B都先锁书1，再锁书2，避免死锁。

#### 例子：线程同步

- **代码**：
    
```
struct resource { int data; struct spinlock lock; };
struct resource r1, r2;

void thread1() {
  acquire(&r1.lock);
  acquire(&r2.lock);
  // 操作r1和r2
  release(&r2.lock);
  release(&r1.lock);
}

void thread2() {
  acquire(&r2.lock);
  acquire(&r1.lock);
  // 操作r1和r2
  release(&r1.lock);
  release(&r2.lock);
}
```
    
- **死锁**：thread1拿r1等r2，thread2拿r2等r1。
- **修正**：统一顺序（如r1→r2）。
