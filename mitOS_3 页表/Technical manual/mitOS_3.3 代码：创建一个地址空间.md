
### 总结重点

1. **核心实现**:
    - vm.c 管理页表，pagetable_t 是根页表指针。
    - walk 查找 PTE（页表条目，64 位值，含 44 位PPN 和 10 位标志位，表示映射或下一级页表)，mappages 创建映射。
2. **内核页表**:
    - kvminit 初始化直接映射，kvminithart 启用分页。
3. **栈管理**:
    - proc_mapstacks 为每个进程映射栈和保护页。
4. **TLB 一致性**:
    - 修改页表后用 sfence.vma 刷新 TLB。
5. **直接映射**:
    - 简化内核操作，依赖 VA = PA。

---

#### 1. **核心数据结构和函数**

- **数据结构**:
    - pagetable_t: 指向 RISC-V 根页表页的指针，可以是内核页表或用户页表。
    - 类比: 像一本书的目录，指向具体章节（页表页）的起始位置。
- **核心函数**:
    - walk: 查找虚拟地址对应的 PTE（页表条目）。
    - mappages: 为虚拟地址范围创建映射。
    - 类比: walk 是查字典找单词定义，mappages 是往字典里添加新词条。
- **示例**:
    - 假设虚拟地址 0x80001000 需要映射到物理地址 0x80001000。
    - walk 返回 PTE 地址，mappages 设置 PTE 为 PPN=0x80001 | PTE_V | PTE_R | PTE_X。  

#### 2. **内核页表初始化 (kvminit 和 kalloc)**

- **过程**:
    - main 调用 kvminit，后者调用 kalloc 创建内核页表。
    - 在分页启用前，使用直接物理地址操作。
    - 分配根页表页，调用 kvmmap 映射内核代码、数据、物理内存和设备。
- **类比**:
    - 像装修房子前先画设计图（根页表），然后标注家具（内核代码）、墙壁（物理内存）的摆放位置。
- **示例**:
    - 分配根页表物理地址 0x80000000。
    - kvmmap 映射：
        - VA 0x80001000 -> PA 0x80001000（内核代码）。
        - VA 0x10000000 -> PA 0x10000000（UART 设备）。
    - 根页表 PTE[1] = 0x80001 | PTE_V | PTE_R | PTE_X。  

#### 3. **映射函数 (kvmmap 和 mappages)**

- **过程**:
    - kvmmap 调用 mappages，按页面大小（4096 字节）为虚拟地址范围创建映射。
    - mappages 用 walk 找到 PTE，设置 PPN 和权限。
- **类比**:
    - 像在地图上标记多个地点（虚拟地址），每个地点指向具体地址（物理地址）。
- **示例**:
    - 映射 VA 0x80001000 - 0x80001FFF 到 PA 0x80001000 - 0x80001FFF：
        - mappages 调用 walk 找到 PTE（例如 0x80000918）。
        - 设置 PTE = 0x80001 | PTE_V | PTE_R | PTE_X。  
    
#### 4. **页表遍历 (walk)**

- **过程**:
    - 模仿 RISC-V 三级页表遍历，使用 VPN[2]、VPN[1]、VPN[0] 逐步查找。
    - 如果 PTE 无效且 alloc=1，分配新页表页。
- **类比**:
    - 像在图书馆找书：先找楼层（VPN[2]），再找书架（VPN[1]），最后找书（VPN[0]）。
- **示例**:
    - 虚拟地址 0x123456789：
        - VPN[2] = 0x123, VPN[1] = 0x8A, VPN[0] = 0x19D。  
        - 从根页表 0x80000000：
            - PTE[0x123] = 0x90000 | PTE_V，下一级 0x90000000。  
            - PTE[0x8A] = 0xA0000 | PTE_V，下一级 0xA0000000。  
            - PTE[0x19D] = 0xB1234 | PTE_V | PTE_R，返回此 PTE。 

#### 5. **直接映射的依赖**

- **概念**:
    - 内核通过直接映射访问物理内存（如 VA 0x80000918 -> PA 0x80000918）。
- **类比**:
    - 像家里地址和门牌号一样，直接用门牌号（物理地址）找房间（虚拟地址）。
- **示例**:
    - walk 读取 PTE 值 0x90000（物理地址 0x90000000），直接用 0x90000000 访问下一级。

#### 6. **启用分页 (kvminithart)**

- **过程**:
    - 将根页表地址写入 satp，启用分页。
    - 直接映射确保指令地址无缝转换。
- **类比**:
    - 像打开导航系统（satp），从此按地图（页表）走路。
- **示例**:
    - satp = 0x80000000，下一条指令 0x80001000 仍映射到 0x80001000。

#### 7. **内核栈分配 (procinit)**

- **过程**:
    - 为每个进程分配内核栈，映射到高地址（如 0x3FFFFE000），下方留保护页。
- **类比**:
    - 像为每个客人准备桌子（栈），旁边放个“禁止入内”牌（保护页）。
- **示例**:
    - 进程 0 栈：
        - VA 0x3FFFFE000 -> PA 0x80200000，PTE = PTE_V | PTE_R | PTE_W。  
        - VA 0x3FFFFD000，PTE = 0（保护页）。  
#### 8. **TLB 刷新 (sfence.vma)**  

- **概念**:
    - 修改页表后，需用 sfence.vma 刷新 TLB，避免使用旧缓存。
- **类比**:
    - 像更新导航地图后，清除手机缓存，确保用新路线。
- **示例**:
    - 修改 PTE（0xB1234 -> 0xC5678），执行 sfence.vma。  
        0xB1234 -3E 0xC5678，也称为“0xC5678”。
    - 否则 TLB 仍缓存旧映射，进程可能访问错误页面。


