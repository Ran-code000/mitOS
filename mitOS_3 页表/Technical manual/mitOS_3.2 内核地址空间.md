### 总结重点

1. **内核页表**：
    - 独立于用户页表，映射物理内存和设备到固定虚拟地址。
2. **直接映射**：
    - 虚拟地址 = 物理地址（如 0x80000000），简化访问。
3. **特殊映射**：
    - 蹦床页面：顶部映射 + 直接映射，用于上下文切换。
    - 内核栈：高地址映射 + 保护页，防止溢出。
4. **权限**：
    - 文本用 PTE_R | PTE_X，数据用 PTE_R | PTE_W，保护页无效。
5. **设计目标**：
    - 直接映射提高效率，高地址映射增强安全性。

---
![[Pasted image 20250317131213.png]]
#### 1. **内核地址空间与页表**

- **概念**:
    - 每个进程有自己的用户页表，描述用户地址空间。
    - 内核维护一个单独的内核页表，描述内核地址空间。
    - 内核页表将物理内存和硬件资源映射到固定的虚拟地址。
- **布局**:
    - 定义在 kernel/memlayout.h 中。
    - 物理内存从 0x80000000（KERNBASE）开始，到 PHYSTOP（例如 0x86400000）。
    - I/O 设备寄存器在 0x80000000 以下。
- **示例**:
    - 假设物理内存中有内核代码位于 0x80001000，内核页表将其映射到虚拟地址 0x80001000。
    - 内核执行 load x1, 0x80001000 时，分页硬件直接访问物理地址 0x80001000，无需偏移。

---

#### 2. **直接映射 (Direct Mapping)**  

- **概念**:
    - 内核将大部分资源映射到虚拟地址等于物理地址的位置。
    - 简化内核访问物理内存和设备寄存器的代码。
- **实现**:
    - 物理地址 0x80000000 到 0x86400000 的 RAM 映射到虚拟地址 0x80000000 到 0x86400000。
    - 设备寄存器（如 0x10000000 的 UART）映射到虚拟地址 0x10000000。
- **示例**:
    - 内核分配器返回物理地址 0x80100000 给子进程用户内存。
    - fork 直接使用 0x80100000 作为虚拟地址复制数据，因为内核页表已将其映射。
    - 访问设备：内核写入虚拟地址 0x10000000（UART 控制寄存器），直接与硬件交互。

---

#### 3. **非直接映射的特殊页面**

##### 3.1 蹦床页面 (Trampoline Page)  

- **概念**:
    - 蹦床页面是一个物理页面，包含切换用户态和内核态的代码。
    - 映射到虚拟地址空间顶部（例如 TRAMPOLINE = 0x3FFFFFF000），同时也被直接映射。
- **用途**:
    - 用于上下文切换（第 4 章详细说明）。
    - 在用户和内核页表中都有映射，确保切换时地址一致。
- **示例**:
    - 假设蹦床代码物理地址为 0x80010000：
        - 内核页表映射：VA 0x80010000 -> PA 0x80010000（直接映射）。
        - 高地址映射：VA 0x3FFFFFF000 -> PA 0x80010000。
    - PTE 设置：PTE_V | PTE_R | PTE_X（可读可执行）。  
    - CPU 执行 call 0x3FFFFFF000，跳转到蹦床代码，完成模式切换。

##### 3.2 内核栈页面 (Kernel Stack Page)  

- **概念**:
    - 每个进程有独立的内核栈，映射到高虚拟地址（例如 0x3FFFFE000）。
    - 栈下方有一个保护页（guard page），PTE 无效（PTE_V=0），防止栈溢出。
- **用途**:
    - 保护页捕获栈溢出，引发异常，避免破坏其他内存。
    - 保护页不占用物理内存，仅占虚拟地址空间。
- **示例**:
    - 进程 A 的内核栈：
        - 栈页面：VA 0x3FFFFE000 -> PA 0x80200000，PTE = PTE_V | PTE_R | PTE_W。  
        - 保护页：VA 0x3FFFFD000，PTE = 0（无效）。
    - 栈溢出：访问 0x3FFFFDFFF（保护页内），触发页面故障，内核调用 panic()。
    - 直接映射访问：内核仍可通过 0x80200000 读写栈。

---

#### 4. **权限设置**

- **标志位**:
    - 蹦床页面和内核文本：PTE_R | PTE_X（可读可执行）。
    - 数据页面（如栈）：PTE_R | PTE_W（可读可写）。
    - 保护页：PTE_V=0（无效）。
- **示例**:
    - 内核文本 PTE（VA 0x80001000）：PPN=0x80001 | PTE_V | PTE_R | PTE_X。  
    - 栈 PTE（VA 0x3FFFFE000）：PPN=0x80200 | PTE_V | PTE_R | PTE_W。  

---

#### 5. **设计权衡**

- **直接映射 vs 高地址映射**:
    - 直接映射便于访问，但难以实现保护页（需要取消映射物理内存）。
    - 高地址映射支持保护页，但需要额外虚拟地址空间管理。
- **示例**:
    - 如果栈只用直接映射（如 0x80200000），保护页需取消映射 0x801FF000，浪费物理内存。
    - 当前设计用高地址 0x3FFFFD000 作为保护页，仅占虚拟空间。

---

### 综合示例

假设进程 A 的内核地址空间配置：

1. **直接映射**：
    - 内核代码：VA 0x80001000 -> PA 0x80001000，PTE = PTE_V | PTE_R | PTE_X。  
    - 物理内存：VA 0x80100000 -> PA 0x80100000，PTE = PTE_V | PTE_R | PTE_W。  
    - UART 寄存器：VA 0x10000000 -> PA 0x10000000，PTE = PTE_V | PTE_R | PTE_W。  
2. **蹦床页面**：
    - 物理地址 0x80020000。
    - 直接映射：VA 0x80020000 -> PA 0x80020000。
    - 高地址映射：VA 0x3FFFFFF000 -> PA 0x80020000，PTE = PTE_V | PTE_R | PTE_X。  
        高地址映射：VA 0x3FFFFFF000 -> PA 0x80020000，PTE = PTE_V |PTE_R |PTE_X。
    - 内核切换到用户态时跳转到 0x3FFFFFF000。
3. **内核栈**：
    - 栈页面：VA 0x3FFFFE000 -> PA 0x80200000，PTE = PTE_V | PTE_R | PTE_W。  
    - 保护页：VA 0x3FFFFD000，PTE = 0（无效）。
    - 栈溢出到 0x3FFFFCFFF，触发页面故障，内核 panic()。
4. **操作**：
    - 内核写入 0x80100000，直接修改物理内存。
    - 栈溢出测试：函数递归调用溢出 0x3FFFFE000，访问 0x3FFFFD000，异常终止。