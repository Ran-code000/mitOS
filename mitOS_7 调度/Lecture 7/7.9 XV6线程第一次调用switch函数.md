（注，首先是学生提问Linux内一个进程多个线程的实现方式，因为在XV6中，一个进程只有一个用户线程）

> 学生提问：操作系统都带了线程的实现，如果想要在多个CPU上运行一个进程内的多个线程，那需要通过操作系统来处理而不是用户空间代码，是吧？那这里的线程切换是怎么工作的？是每个线程都与进程一样了吗？操作系统还会遍历所有存在的线程吗？比如说我们有8个核，每个CPU核都会在多个进程的更多个线程之间切换。同时我们也不想只在一个CPU核上切换一个进程的多个线程，是吧？
> 
> Robert教授：Linux是支持一个进程包含多个线程，Linux的实现比较复杂，或许最简单的解释方式是：几乎可以认为Linux中的每个线程都是一个完整的进程。Linux中，我们平常说一个进程中的多个线程，本质上是共享同一块内存的多个独立进程。所以Linux中一个进程的多个线程仍然是通过一个内存地址空间执行代码。如果你在一个进程创建了2个线程，那基本上是2个进程共享一个地址空间。之后，调度就与XV6是一致的，也就是针对每个进程进行调度。
- **多核运行**：需要操作系统调度线程到不同核，用户空间无权直接控制。
- **线程切换**：类似进程切换，但开销更小，只切换线程私有上下文。
- **线程 vs 进程**：线程是轻量级进程，共享资源但独立调度。
- **遍历**：多核下每个核遍历自己的线程队列，内核动态均衡负载。
	- **每个核独立调度**：
	    - 每个 CPU 核有自己的运行队列，避免全局锁竞争。
	    - 调度器只遍历当前核的队列，选择线程运行。
	- **负载均衡**：
	    - 内核定期检查各核的负载，将线程从繁忙核迁移到空闲核。
		    - 不需要遍历所有线程，只需检查队列长度或核状态。
	- **实现**：
	    - Linux 使用 CFS（Completely Fair Scheduler），每个核有红黑树队列，按公平性选择线程。
	    - 不直接遍历所有线程，而是动态调整。
	- **目标**：避免单核切换，利用多核并行性。

> 学生提问：用户可以指定将线程绑定在某个CPU上吗？操作系统如何确保一个进程的多个线程不会运行在同一个CPU核上？要不然就违背了多线程的初衷了。
> 
> Robert教授：这里其实与XV6非常相似，假设有4个CPU核，Linux会找到4件事情运行在这4个核上。如果并没有太多正在运行的程序的话，或许会将一个进程的4个线程运行在4个核上。或者如果有100个用户登录在Athena机器上，内核会随机为每个CPU核找到一些事情做。
> 
> 如果你想做一些精细的测试，有一些方法可以将线程绑定在CPU核上，但正常情况下人们不会这么做。


> 学生提问：所以说一个进程中的多个线程会有相同的page table？
> 
> Robert教授：是的，如果你在Linux上，你为一个进程创建了2个线程，我不确定它们是不是共享同一个的page table，还是说它们是不同的page table，但是内容是相同的。
> 
是的，一个进程中的所有线程共享相同的页面表，因为它们共享进程的虚拟地址空间。这是线程设计的核心特性，确保线程间高效通信和协作。
 补充：
- **例外情况**：某些特殊实现（例如用户级线程）可能不完全依赖内核页面表，但现代操作系统（如 Linux）的内核线程都共享进程的页面表。
- **多核调度**：线程共享页面表不影响它们在不同核上运行，内核只需为每个线程分配独立的栈和上下文。

> 学生提问：有没有原因说这里的page table要是分开的？
> 
> Robert教授：我不知道Linux究竟用了哪种方法。

（注，以下是线程第一次调用switch的过程）

> 学生提问：当调用swtch函数的时候，实际上是从一个线程对于switch的调用切换到了另一个线程对于switch的调用。所以线程第一次调用swtch函数时，需要伪造一个“另一个线程”对于switch的调用，是吧？因为也不能通过swtch函数随机跳到其他代码去。
> 
> Robert教授：是的。我们来看一下第一次调用switch时，“另一个”调用swtch函数的线程的context对象。proc.c文件中的allocproc函数会被启动时的第一个进程和fork调用，allocproc会设置好新进程的context，如下所示：

[![](https://github.com/huihongxiao/MIT6.S081/raw/master/.gitbook/assets/image%20(442).png)](https://github.com/huihongxiao/MIT6.S081/blob/master/.gitbook/assets/image%20\(442\).png)

> 实际上大部分寄存器的内容都无所谓。但是**ra很重要，因为这是进程的第一个switch调用会返回的位置**。同时因为**进程需要有自己的栈，所以ra和sp都被设置了。这里设置的forkret函数就是进程的第一次调用swtch函数会切换到的“另一个”线程位置**。
- 是的，第一次调用 swtch 时，目标线程的上下文需要伪造。
- 伪造的内容是线程的初始状态（栈和入口函数），模拟它“之前调用过 swtch”。
- 不能随机跳转，因为 swtch 需要明确的跳转地址和栈位置，否则会崩溃。
澄清
- 不是伪造“另一个线程的 swtch 调用”，而是伪造目标线程的初始上下文，让它看起来像是从 swtch 返回。
- 伪造发生在线程创建时，而不是 swtch 内部。

> 学生提问：所以当swtch函数返回时，CPU会执行forkret中的指令，就像forkret刚刚调用了swtch函数并且返回了一样？
> 
> Robert教授：是的，从switch返回就直接跳到了forkret的最开始位置。


> 学生提问：我们会在其他场合调用forkret吗？还是说它只会用在这？
> 
> Robert教授：是的，它**只会在启动进程的时候以这种奇怪的方式运行**。下面是forkret函数的代码，

[![](https://github.com/huihongxiao/MIT6.S081/raw/master/.gitbook/assets/image%20(422).png)](https://github.com/huihongxiao/MIT6.S081/blob/master/.gitbook/assets/image%20\(422\).png)

> 从代码中看，它的工作其实就是释放调度器之前获取的锁。函数最后的usertrapret函数其实也是一个假的函数，它会使得程序表现的看起来像是从trap中返回，但是对应的trapframe其实也是假的，这样才能跳到用户的第一个指令中。
- **是的，但有条件**：
    - 对于新创建的进程（第一次切换），swtch 返回时确实会执行 forkret 中的指令。
    - 这是因为新进程的上下文被伪造，context.ra 被设置为 forkret，所以 swtch “返回”到 forkret 的开头。
- **“就像 forkret 刚刚调用了 swtch 并返回”**：
    - 从 CPU 的视角看，确实像是这样。
    - swtch 加载 ra = forkret，返回时 CPU 从 forkret 开始执行，仿佛 forkret 之前调用了 swtch 并刚返回。
    - 但实际上，forkret 从未调用 swtch，这是伪造的结果。

#### 普通进程 vs 新进程

- **普通进程**：
    - swtch 返回到调用者（例如 sched）的下一条指令。
- **新进程**：
    - swtch 返回到伪造的 forkret，因为它是第一次运行。
### 总结

- **新进程第一次 swtch**：
    - 返回时执行 forkret，因为 context.ra 被设为 forkret。
- **伪造效果**：
    - 看起来像是 forkret 调用了 swtch 并返回，但实际上是初始化时设置的。
- **原因**：
    - 新进程需要一个起点，forkret 是从内核态到用户态的桥梁。

> 学生提问：与之前的context对象类似的是，对于trapframe也不用初始化任何寄存器，因为我们要去的是程序的最开始，所以不需要做任何假设，对吧？
> 
> Robert教授：我认为程序计数器还是要被初始化为0的。

[![](https://github.com/huihongxiao/MIT6.S081/raw/master/.gitbook/assets/image%20(512).png)](https://github.com/huihongxiao/MIT6.S081/blob/master/.gitbook/assets/image%20\(512\).png)

> 因为fork拷贝的进程会同时拷贝父进程的程序计数器，所以我们唯一不是通过fork创建进程的场景就是创建第一个进程的时候。这时需要设置程序计数器为0。
-  对于新进程的 trapframe，不需要初始化所有寄存器，只需设置 epc（程序入口）和 sp（栈指针）。
    - 因为是“程序的最开始”，没有历史状态需要恢复，用户代码会自己初始化所需值。
- **小修正**：
    - 不是“完全不初始化”，而是只需初始化关键字段（epc 和 sp），其他寄存器可以留空或默认。
    - 这与 context 的伪造类似，只设置必要部分。

> 学生提问：在fortret函数中，if(first)是什么意思？
> 
> Robert教授：文件系统需要被初始化，具体来说，需要从磁盘读取一些数据来确保文件系统的运行，比如说文件系统究竟有多大，各种各样的东西在文件系统的哪个位置，同时还需要有crash recovery log。完成任何文件系统的操作都需要等待磁盘操作结束，但是XV6只能在进程的context下执行文件系统操作，比如等待I/O。所以初始化文件系统需要等到我们有了一个进程才能进行。而这一步是在第一次调用forkret时完成的，所以在forkret中才有了if(first)判断。